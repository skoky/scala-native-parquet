/**
 * Generated by Scrooge
 *   version: 4.16.0-SNAPSHOT
 *   rev: eb110c820bcd2734b26023f24d636bf6d37511b3
 *   built at: 20170607-185808
 */
package parquet.format

import com.twitter.scrooge.ThriftEnum
import scala.collection.immutable.{Map => immutable$Map}

/**
 * Encodings supported by Parquet.  Not all encodings are valid for all types.  These
 * enums are also used to specify the encoding of definition and repetition levels.
 * See the accompanying doc for the details of the more complicated encodings.
 */
@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
case object Encoding {

  val annotations: immutable$Map[String, String] = immutable$Map.empty

  /** Default encoding.
   * BOOLEAN - 1 bit per value. 0 is false; 1 is true.
   * INT32 - 4 bytes per value.  Stored as little-endian.
   * INT64 - 8 bytes per value.  Stored as little-endian.
   * FLOAT - 4 bytes per value.  IEEE. Stored as little-endian.
   * DOUBLE - 8 bytes per value.  IEEE. Stored as little-endian.
   * BYTE_ARRAY - 4 byte length stored as little endian, followed by bytes.
   * FIXED_LEN_BYTE_ARRAY - Just the bytes.
   */
  case object Plain extends parquet.format.Encoding {
    val value: Int = 0
    val name: String = "Plain"
    val originalName: String = "PLAIN"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomePlain = _root_.scala.Some(parquet.format.Encoding.Plain)
  /** Group VarInt encoding for INT32/INT64.
   * This encoding is deprecated. It was never used
   */
/**
   * Deprecated: Dictionary encoding. The values in the dictionary are encoded in the
   * plain type.
   * in a data page use RLE_DICTIONARY instead.
   * in a Dictionary page use PLAIN instead
   */
  case object PlainDictionary extends parquet.format.Encoding {
    val value: Int = 2
    val name: String = "PlainDictionary"
    val originalName: String = "PLAIN_DICTIONARY"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomePlainDictionary = _root_.scala.Some(parquet.format.Encoding.PlainDictionary)
  /** Group packed run length encoding. Usable for definition/reptition levels
   * encoding and Booleans (on one bit: 0 is false; 1 is true.)
   */
  case object Rle extends parquet.format.Encoding {
    val value: Int = 3
    val name: String = "Rle"
    val originalName: String = "RLE"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeRle = _root_.scala.Some(parquet.format.Encoding.Rle)
  /** Bit packed encoding.  This can only be used if the data has a known max
   * width.  Usable for definition/repetition levels encoding.
   */
  case object BitPacked extends parquet.format.Encoding {
    val value: Int = 4
    val name: String = "BitPacked"
    val originalName: String = "BIT_PACKED"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeBitPacked = _root_.scala.Some(parquet.format.Encoding.BitPacked)
  /** Delta encoding for integers. This can be used for int columns and works best
   * on sorted data
   */
  case object DeltaBinaryPacked extends parquet.format.Encoding {
    val value: Int = 5
    val name: String = "DeltaBinaryPacked"
    val originalName: String = "DELTA_BINARY_PACKED"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeDeltaBinaryPacked = _root_.scala.Some(parquet.format.Encoding.DeltaBinaryPacked)
  /** Encoding for byte arrays to separate the length values and the data. The lengths
   * are encoded using DELTA_BINARY_PACKED
   */
  case object DeltaLengthByteArray extends parquet.format.Encoding {
    val value: Int = 6
    val name: String = "DeltaLengthByteArray"
    val originalName: String = "DELTA_LENGTH_BYTE_ARRAY"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeDeltaLengthByteArray = _root_.scala.Some(parquet.format.Encoding.DeltaLengthByteArray)
  /** Incremental-encoded byte array. Prefix lengths are encoded using DELTA_BINARY_PACKED.
   * Suffixes are stored as delta length byte arrays.
   */
  case object DeltaByteArray extends parquet.format.Encoding {
    val value: Int = 7
    val name: String = "DeltaByteArray"
    val originalName: String = "DELTA_BYTE_ARRAY"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeDeltaByteArray = _root_.scala.Some(parquet.format.Encoding.DeltaByteArray)
  /** Dictionary encoding: the ids are encoded using the RLE encoding
   */
  case object RleDictionary extends parquet.format.Encoding {
    val value: Int = 8
    val name: String = "RleDictionary"
    val originalName: String = "RLE_DICTIONARY"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeRleDictionary = _root_.scala.Some(parquet.format.Encoding.RleDictionary)

  case class EnumUnknownEncoding(value: Int) extends parquet.format.Encoding {
    val name: String = "EnumUnknownEncoding" + value
    def originalName: String = name
  }

  /**
   * Find the enum by its integer value, as defined in the Thrift IDL.
   */
  def apply(value: Int): parquet.format.Encoding =
    value match {
      case 0 => parquet.format.Encoding.Plain
      case 2 => parquet.format.Encoding.PlainDictionary
      case 3 => parquet.format.Encoding.Rle
      case 4 => parquet.format.Encoding.BitPacked
      case 5 => parquet.format.Encoding.DeltaBinaryPacked
      case 6 => parquet.format.Encoding.DeltaLengthByteArray
      case 7 => parquet.format.Encoding.DeltaByteArray
      case 8 => parquet.format.Encoding.RleDictionary
      case _ => throw new NoSuchElementException(value.toString)
    }

  /**
   * Find the enum by its integer value, as defined in the Thrift IDL.
   * returns an EnumUnknownEncoding(value) if the value is not found.
   * In particular this allows ignoring new values added to an enum
   * in the IDL on the producer side when the consumer was not updated.
   */
  def getOrUnknown(value: Int): parquet.format.Encoding =
    get(value) match {
      case _root_.scala.Some(e) => e
      case _root_.scala.None => EnumUnknownEncoding(value)
    }

  /**
   * Find the enum by its integer value, as defined in the Thrift IDL.
   * Returns None if the value is not found
   */
  def get(value: Int): _root_.scala.Option[parquet.format.Encoding] =
    value match {
      case 0 => _SomePlain
      case 2 => _SomePlainDictionary
      case 3 => _SomeRle
      case 4 => _SomeBitPacked
      case 5 => _SomeDeltaBinaryPacked
      case 6 => _SomeDeltaLengthByteArray
      case 7 => _SomeDeltaByteArray
      case 8 => _SomeRleDictionary
      case _ => _root_.scala.None
    }

  def valueOf(name: String): _root_.scala.Option[parquet.format.Encoding] =
    name.toLowerCase match {
      case "plain" => _SomePlain
      case "plaindictionary" => _SomePlainDictionary
      case "rle" => _SomeRle
      case "bitpacked" => _SomeBitPacked
      case "deltabinarypacked" => _SomeDeltaBinaryPacked
      case "deltalengthbytearray" => _SomeDeltaLengthByteArray
      case "deltabytearray" => _SomeDeltaByteArray
      case "rledictionary" => _SomeRleDictionary
      case _ => _root_.scala.None
    }

  lazy val list: List[parquet.format.Encoding] = scala.List[parquet.format.Encoding](
    parquet.format.Encoding.Plain,
    parquet.format.Encoding.PlainDictionary,
    parquet.format.Encoding.Rle,
    parquet.format.Encoding.BitPacked,
    parquet.format.Encoding.DeltaBinaryPacked,
    parquet.format.Encoding.DeltaLengthByteArray,
    parquet.format.Encoding.DeltaByteArray,
    parquet.format.Encoding.RleDictionary
  )
}


/**
 * Encodings supported by Parquet.  Not all encodings are valid for all types.  These
 * enums are also used to specify the encoding of definition and repetition levels.
 * See the accompanying doc for the details of the more complicated encodings.
 */
@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
sealed trait Encoding extends ThriftEnum with Serializable