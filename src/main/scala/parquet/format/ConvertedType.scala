/**
 * Generated by Scrooge
 *   version: 4.16.0-SNAPSHOT
 *   rev: eb110c820bcd2734b26023f24d636bf6d37511b3
 *   built at: 20170607-185808
 */
package parquet.format

import com.twitter.scrooge.ThriftEnum
import scala.collection.immutable.{Map => immutable$Map}

/**
 * Common types used by frameworks(e.g. hive, pig) using parquet.  This helps map
 * between types in those frameworks to the base types in parquet.  This is only
 * metadata and not needed to read or write the data.
 */
@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
case object ConvertedType {

  val annotations: immutable$Map[String, String] = immutable$Map.empty

  /** a BYTE_ARRAY actually contains UTF8 encoded chars */
  case object Utf8 extends parquet.format.ConvertedType {
    val value: Int = 0
    val name: String = "Utf8"
    val originalName: String = "UTF8"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeUtf8 = _root_.scala.Some(parquet.format.ConvertedType.Utf8)
  /** a map is converted as an optional field containing a repeated key/value pair */
  case object Map extends parquet.format.ConvertedType {
    val value: Int = 1
    val name: String = "Map"
    val originalName: String = "MAP"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeMap = _root_.scala.Some(parquet.format.ConvertedType.Map)
  /** a key/value pair is converted into a group of two fields */
  case object MapKeyValue extends parquet.format.ConvertedType {
    val value: Int = 2
    val name: String = "MapKeyValue"
    val originalName: String = "MAP_KEY_VALUE"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeMapKeyValue = _root_.scala.Some(parquet.format.ConvertedType.MapKeyValue)
  /** a list is converted into an optional field containing a repeated field for its
   * values */
  case object List extends parquet.format.ConvertedType {
    val value: Int = 3
    val name: String = "List"
    val originalName: String = "LIST"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeList = _root_.scala.Some(parquet.format.ConvertedType.List)
  /** an enum is converted into a binary field */
  case object Enum extends parquet.format.ConvertedType {
    val value: Int = 4
    val name: String = "Enum"
    val originalName: String = "ENUM"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeEnum = _root_.scala.Some(parquet.format.ConvertedType.Enum)
  /**
   * A decimal value.
   *
   * This may be used to annotate binary or fixed primitive types. The
   * underlying byte array stores the unscaled value encoded as two's
   * complement using big-endian byte order (the most significant byte is the
   * zeroth element). The value of the decimal is the value * 10^{-scale}.
   *
   * This must be accompanied by a (maximum) precision and a scale in the
   * SchemaElement. The precision specifies the number of digits in the decimal
   * and the scale stores the location of the decimal point. For example 1.23
   * would have precision 3 (3 total digits) and scale 2 (the decimal point is
   * 2 digits over).
   */
  case object Decimal extends parquet.format.ConvertedType {
    val value: Int = 5
    val name: String = "Decimal"
    val originalName: String = "DECIMAL"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeDecimal = _root_.scala.Some(parquet.format.ConvertedType.Decimal)
  /**
   * A Date
   *
   * Stored as days since Unix epoch, encoded as the INT32 physical type.
   *
   */
  case object Date extends parquet.format.ConvertedType {
    val value: Int = 6
    val name: String = "Date"
    val originalName: String = "DATE"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeDate = _root_.scala.Some(parquet.format.ConvertedType.Date)
  /**
   * A time
   *
   * The total number of milliseconds since midnight.  The value is stored
   * as an INT32 physical type.
   */
  case object TimeMillis extends parquet.format.ConvertedType {
    val value: Int = 7
    val name: String = "TimeMillis"
    val originalName: String = "TIME_MILLIS"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeTimeMillis = _root_.scala.Some(parquet.format.ConvertedType.TimeMillis)
  /**
   * A time.
   *
   * The total number of microseconds since midnight.  The value is stored as
   * an INT64 physical type.
   */
  case object TimeMicros extends parquet.format.ConvertedType {
    val value: Int = 8
    val name: String = "TimeMicros"
    val originalName: String = "TIME_MICROS"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeTimeMicros = _root_.scala.Some(parquet.format.ConvertedType.TimeMicros)
  /**
   * A date/time combination
   *
   * Date and time recorded as milliseconds since the Unix epoch.  Recorded as
   * a physical type of INT64.
   */
  case object TimestampMillis extends parquet.format.ConvertedType {
    val value: Int = 9
    val name: String = "TimestampMillis"
    val originalName: String = "TIMESTAMP_MILLIS"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeTimestampMillis = _root_.scala.Some(parquet.format.ConvertedType.TimestampMillis)
  /**
   * A date/time combination
   *
   * Date and time recorded as microseconds since the Unix epoch.  The value is
   * stored as an INT64 physical type.
   */
  case object TimestampMicros extends parquet.format.ConvertedType {
    val value: Int = 10
    val name: String = "TimestampMicros"
    val originalName: String = "TIMESTAMP_MICROS"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeTimestampMicros = _root_.scala.Some(parquet.format.ConvertedType.TimestampMicros)
  /**
   * An unsigned integer value.
   *
   * The number describes the maximum number of meainful data bits in
   * the stored value. 8, 16 and 32 bit values are stored using the
   * INT32 physical type.  64 bit values are stored using the INT64
   * physical type.
   *
   */
  case object Uint8 extends parquet.format.ConvertedType {
    val value: Int = 11
    val name: String = "Uint8"
    val originalName: String = "UINT_8"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeUint8 = _root_.scala.Some(parquet.format.ConvertedType.Uint8)
  
  case object Uint16 extends parquet.format.ConvertedType {
    val value: Int = 12
    val name: String = "Uint16"
    val originalName: String = "UINT_16"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeUint16 = _root_.scala.Some(parquet.format.ConvertedType.Uint16)
  
  case object Uint32 extends parquet.format.ConvertedType {
    val value: Int = 13
    val name: String = "Uint32"
    val originalName: String = "UINT_32"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeUint32 = _root_.scala.Some(parquet.format.ConvertedType.Uint32)
  
  case object Uint64 extends parquet.format.ConvertedType {
    val value: Int = 14
    val name: String = "Uint64"
    val originalName: String = "UINT_64"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeUint64 = _root_.scala.Some(parquet.format.ConvertedType.Uint64)
  /**
   * A signed integer value.
   *
   * The number describes the maximum number of meainful data bits in
   * the stored value. 8, 16 and 32 bit values are stored using the
   * INT32 physical type.  64 bit values are stored using the INT64
   * physical type.
   *
   */
  case object Int8 extends parquet.format.ConvertedType {
    val value: Int = 15
    val name: String = "Int8"
    val originalName: String = "INT_8"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeInt8 = _root_.scala.Some(parquet.format.ConvertedType.Int8)
  
  case object Int16 extends parquet.format.ConvertedType {
    val value: Int = 16
    val name: String = "Int16"
    val originalName: String = "INT_16"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeInt16 = _root_.scala.Some(parquet.format.ConvertedType.Int16)
  
  case object Int32 extends parquet.format.ConvertedType {
    val value: Int = 17
    val name: String = "Int32"
    val originalName: String = "INT_32"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeInt32 = _root_.scala.Some(parquet.format.ConvertedType.Int32)
  
  case object Int64 extends parquet.format.ConvertedType {
    val value: Int = 18
    val name: String = "Int64"
    val originalName: String = "INT_64"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeInt64 = _root_.scala.Some(parquet.format.ConvertedType.Int64)
  /**
   * An embedded JSON document
   *
   * A JSON document embedded within a single UTF8 column.
   */
  case object Json extends parquet.format.ConvertedType {
    val value: Int = 19
    val name: String = "Json"
    val originalName: String = "JSON"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeJson = _root_.scala.Some(parquet.format.ConvertedType.Json)
  /**
   * An embedded BSON document
   *
   * A BSON document embedded within a single BINARY column.
   */
  case object Bson extends parquet.format.ConvertedType {
    val value: Int = 20
    val name: String = "Bson"
    val originalName: String = "BSON"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeBson = _root_.scala.Some(parquet.format.ConvertedType.Bson)
  /**
   * An interval of time
   *
   * This type annotates data stored as a FIXED_LEN_BYTE_ARRAY of length 12
   * This data is composed of three separate little endian unsigned
   * integers.  Each stores a component of a duration of time.  The first
   * integer identifies the number of months associated with the duration,
   * the second identifies the number of days associated with the duration
   * and the third identifies the number of milliseconds associated with
   * the provided duration.  This duration of time is independent of any
   * particular timezone or date.
   */
  case object Interval extends parquet.format.ConvertedType {
    val value: Int = 21
    val name: String = "Interval"
    val originalName: String = "INTERVAL"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeInterval = _root_.scala.Some(parquet.format.ConvertedType.Interval)

  case class EnumUnknownConvertedType(value: Int) extends parquet.format.ConvertedType {
    val name: String = "EnumUnknownConvertedType" + value
    def originalName: String = name
  }

  /**
   * Find the enum by its integer value, as defined in the Thrift IDL.
   */
  def apply(value: Int): parquet.format.ConvertedType =
    value match {
      case 0 => parquet.format.ConvertedType.Utf8
      case 1 => parquet.format.ConvertedType.Map
      case 2 => parquet.format.ConvertedType.MapKeyValue
      case 3 => parquet.format.ConvertedType.List
      case 4 => parquet.format.ConvertedType.Enum
      case 5 => parquet.format.ConvertedType.Decimal
      case 6 => parquet.format.ConvertedType.Date
      case 7 => parquet.format.ConvertedType.TimeMillis
      case 8 => parquet.format.ConvertedType.TimeMicros
      case 9 => parquet.format.ConvertedType.TimestampMillis
      case 10 => parquet.format.ConvertedType.TimestampMicros
      case 11 => parquet.format.ConvertedType.Uint8
      case 12 => parquet.format.ConvertedType.Uint16
      case 13 => parquet.format.ConvertedType.Uint32
      case 14 => parquet.format.ConvertedType.Uint64
      case 15 => parquet.format.ConvertedType.Int8
      case 16 => parquet.format.ConvertedType.Int16
      case 17 => parquet.format.ConvertedType.Int32
      case 18 => parquet.format.ConvertedType.Int64
      case 19 => parquet.format.ConvertedType.Json
      case 20 => parquet.format.ConvertedType.Bson
      case 21 => parquet.format.ConvertedType.Interval
      case _ => throw new NoSuchElementException(value.toString)
    }

  /**
   * Find the enum by its integer value, as defined in the Thrift IDL.
   * returns an EnumUnknownConvertedType(value) if the value is not found.
   * In particular this allows ignoring new values added to an enum
   * in the IDL on the producer side when the consumer was not updated.
   */
  def getOrUnknown(value: Int): parquet.format.ConvertedType =
    get(value) match {
      case _root_.scala.Some(e) => e
      case _root_.scala.None => EnumUnknownConvertedType(value)
    }

  /**
   * Find the enum by its integer value, as defined in the Thrift IDL.
   * Returns None if the value is not found
   */
  def get(value: Int): _root_.scala.Option[parquet.format.ConvertedType] =
    value match {
      case 0 => _SomeUtf8
      case 1 => _SomeMap
      case 2 => _SomeMapKeyValue
      case 3 => _SomeList
      case 4 => _SomeEnum
      case 5 => _SomeDecimal
      case 6 => _SomeDate
      case 7 => _SomeTimeMillis
      case 8 => _SomeTimeMicros
      case 9 => _SomeTimestampMillis
      case 10 => _SomeTimestampMicros
      case 11 => _SomeUint8
      case 12 => _SomeUint16
      case 13 => _SomeUint32
      case 14 => _SomeUint64
      case 15 => _SomeInt8
      case 16 => _SomeInt16
      case 17 => _SomeInt32
      case 18 => _SomeInt64
      case 19 => _SomeJson
      case 20 => _SomeBson
      case 21 => _SomeInterval
      case _ => _root_.scala.None
    }

  def valueOf(name: String): _root_.scala.Option[parquet.format.ConvertedType] =
    name.toLowerCase match {
      case "utf8" => _SomeUtf8
      case "map" => _SomeMap
      case "mapkeyvalue" => _SomeMapKeyValue
      case "list" => _SomeList
      case "enum" => _SomeEnum
      case "decimal" => _SomeDecimal
      case "date" => _SomeDate
      case "timemillis" => _SomeTimeMillis
      case "timemicros" => _SomeTimeMicros
      case "timestampmillis" => _SomeTimestampMillis
      case "timestampmicros" => _SomeTimestampMicros
      case "uint8" => _SomeUint8
      case "uint16" => _SomeUint16
      case "uint32" => _SomeUint32
      case "uint64" => _SomeUint64
      case "int8" => _SomeInt8
      case "int16" => _SomeInt16
      case "int32" => _SomeInt32
      case "int64" => _SomeInt64
      case "json" => _SomeJson
      case "bson" => _SomeBson
      case "interval" => _SomeInterval
      case _ => _root_.scala.None
    }

  lazy val list: List[parquet.format.ConvertedType] = scala.List[parquet.format.ConvertedType](
    parquet.format.ConvertedType.Utf8,
    parquet.format.ConvertedType.Map,
    parquet.format.ConvertedType.MapKeyValue,
    parquet.format.ConvertedType.List,
    parquet.format.ConvertedType.Enum,
    parquet.format.ConvertedType.Decimal,
    parquet.format.ConvertedType.Date,
    parquet.format.ConvertedType.TimeMillis,
    parquet.format.ConvertedType.TimeMicros,
    parquet.format.ConvertedType.TimestampMillis,
    parquet.format.ConvertedType.TimestampMicros,
    parquet.format.ConvertedType.Uint8,
    parquet.format.ConvertedType.Uint16,
    parquet.format.ConvertedType.Uint32,
    parquet.format.ConvertedType.Uint64,
    parquet.format.ConvertedType.Int8,
    parquet.format.ConvertedType.Int16,
    parquet.format.ConvertedType.Int32,
    parquet.format.ConvertedType.Int64,
    parquet.format.ConvertedType.Json,
    parquet.format.ConvertedType.Bson,
    parquet.format.ConvertedType.Interval
  )
}


/**
 * Common types used by frameworks(e.g. hive, pig) using parquet.  This helps map
 * between types in those frameworks to the base types in parquet.  This is only
 * metadata and not needed to read or write the data.
 */
@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
sealed trait ConvertedType extends ThriftEnum with Serializable