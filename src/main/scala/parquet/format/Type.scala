/**
 * Generated by Scrooge
 *   version: 4.16.0-SNAPSHOT
 *   rev: eb110c820bcd2734b26023f24d636bf6d37511b3
 *   built at: 20170607-185808
 */
package parquet.format

import com.twitter.scrooge.ThriftEnum
import scala.collection.immutable.{Map => immutable$Map}

/**
 * Types supported by Parquet.  These types are intended to be used in combination
 * with the encodings to control the on disk storage format.
 * For example INT16 is not included as a type since a good encoding of INT32
 * would handle this.
 */
@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
case object Type {

  val annotations: immutable$Map[String, String] = immutable$Map.empty

  
  case object Boolean extends parquet.format.Type {
    val value: Int = 0
    val name: String = "Boolean"
    val originalName: String = "BOOLEAN"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeBoolean = _root_.scala.Some(parquet.format.Type.Boolean)
  
  case object Int32 extends parquet.format.Type {
    val value: Int = 1
    val name: String = "Int32"
    val originalName: String = "INT32"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeInt32 = _root_.scala.Some(parquet.format.Type.Int32)
  
  case object Int64 extends parquet.format.Type {
    val value: Int = 2
    val name: String = "Int64"
    val originalName: String = "INT64"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeInt64 = _root_.scala.Some(parquet.format.Type.Int64)
  
  case object Int96 extends parquet.format.Type {
    val value: Int = 3
    val name: String = "Int96"
    val originalName: String = "INT96"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeInt96 = _root_.scala.Some(parquet.format.Type.Int96)
  
  case object Float extends parquet.format.Type {
    val value: Int = 4
    val name: String = "Float"
    val originalName: String = "FLOAT"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeFloat = _root_.scala.Some(parquet.format.Type.Float)
  
  case object Double extends parquet.format.Type {
    val value: Int = 5
    val name: String = "Double"
    val originalName: String = "DOUBLE"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeDouble = _root_.scala.Some(parquet.format.Type.Double)
  
  case object ByteArray extends parquet.format.Type {
    val value: Int = 6
    val name: String = "ByteArray"
    val originalName: String = "BYTE_ARRAY"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeByteArray = _root_.scala.Some(parquet.format.Type.ByteArray)
  
  case object FixedLenByteArray extends parquet.format.Type {
    val value: Int = 7
    val name: String = "FixedLenByteArray"
    val originalName: String = "FIXED_LEN_BYTE_ARRAY"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeFixedLenByteArray = _root_.scala.Some(parquet.format.Type.FixedLenByteArray)

  case class EnumUnknownType(value: Int) extends parquet.format.Type {
    val name: String = "EnumUnknownType" + value
    def originalName: String = name
  }

  /**
   * Find the enum by its integer value, as defined in the Thrift IDL.
   */
  def apply(value: Int): parquet.format.Type =
    value match {
      case 0 => parquet.format.Type.Boolean
      case 1 => parquet.format.Type.Int32
      case 2 => parquet.format.Type.Int64
      case 3 => parquet.format.Type.Int96
      case 4 => parquet.format.Type.Float
      case 5 => parquet.format.Type.Double
      case 6 => parquet.format.Type.ByteArray
      case 7 => parquet.format.Type.FixedLenByteArray
      case _ => throw new NoSuchElementException(value.toString)
    }

  /**
   * Find the enum by its integer value, as defined in the Thrift IDL.
   * returns an EnumUnknownType(value) if the value is not found.
   * In particular this allows ignoring new values added to an enum
   * in the IDL on the producer side when the consumer was not updated.
   */
  def getOrUnknown(value: Int): parquet.format.Type =
    get(value) match {
      case _root_.scala.Some(e) => e
      case _root_.scala.None => EnumUnknownType(value)
    }

  /**
   * Find the enum by its integer value, as defined in the Thrift IDL.
   * Returns None if the value is not found
   */
  def get(value: Int): _root_.scala.Option[parquet.format.Type] =
    value match {
      case 0 => _SomeBoolean
      case 1 => _SomeInt32
      case 2 => _SomeInt64
      case 3 => _SomeInt96
      case 4 => _SomeFloat
      case 5 => _SomeDouble
      case 6 => _SomeByteArray
      case 7 => _SomeFixedLenByteArray
      case _ => _root_.scala.None
    }

  def valueOf(name: String): _root_.scala.Option[parquet.format.Type] =
    name.toLowerCase match {
      case "boolean" => _SomeBoolean
      case "int32" => _SomeInt32
      case "int64" => _SomeInt64
      case "int96" => _SomeInt96
      case "float" => _SomeFloat
      case "double" => _SomeDouble
      case "bytearray" => _SomeByteArray
      case "fixedlenbytearray" => _SomeFixedLenByteArray
      case _ => _root_.scala.None
    }

  lazy val list: List[parquet.format.Type] = scala.List[parquet.format.Type](
    parquet.format.Type.Boolean,
    parquet.format.Type.Int32,
    parquet.format.Type.Int64,
    parquet.format.Type.Int96,
    parquet.format.Type.Float,
    parquet.format.Type.Double,
    parquet.format.Type.ByteArray,
    parquet.format.Type.FixedLenByteArray
  )
}


/**
 * Types supported by Parquet.  These types are intended to be used in combination
 * with the encodings to control the on disk storage format.
 * For example INT16 is not included as a type since a good encoding of INT32
 * would handle this.
 */
@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
sealed trait Type extends ThriftEnum with Serializable